<!doctype html>
<html lang="en">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>The Document Object Model Is Dead - Boris Skurikhin</title>
  <style>
    body {
      background: #fff;
      color: #333;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      max-width: 650px;
      margin: 4rem auto;
      padding: 0 1rem;
      line-height: 1.6;
      font-size: 18px;
    }
    h1, h2, h3 { line-height: 1.2; }
    .header { display: flex; align-items: center; gap: 1.5rem; margin-bottom: 2rem; }
    .header h1 { margin: 0; }
    a { color: #0070f3; text-decoration: underline; }
    a:hover { color: #0051a8; }
    hr { border: none; border-top: 1px solid #ccc; margin: 2rem 0; }
    code { background: #f5f5f5; padding: 0.2em 0.4em; border-radius: 4px; }
    blockquote { margin: 1.5rem 0; padding-left: 1rem; border-left: 3px solid #ddd; color: #666; }
    blockquote footer { margin-top: 0.5rem; font-size: 0.9em; color: #999; }
    .article-meta { font-size: 14px; color: #666; margin-bottom: 2rem; }
  </style>
  <body>
    <div class="header">
      <h1>The Document Object Model Is Dead: Stop Testing Like It's 2010</h1>
    </div>

    <p>Published in <a href="https://www.forbes.com/councils/forbesbusinesscouncil/2025/09/12/the-document-object-model-is-dead-stop-testing-like-its-2010/">Forbes Business Council</a>, September 2025</p>

    <p>A common misconception in automated software testing is that the document object model (DOM) is still the best way to interact with a web application. But this is less helpful when most front ends are stitched together from overly complex DOMs and megabytes of runtime logic.</p>

    <p>Quality assurance of software, increasingly written by swarms of AI-assisted developers, has become one of the hottest topics in Silicon Valley. It's the nuclear fallout of the LLM boom and the vibe-code epidemic of 2025. What was once seen as arcane wizardry performed by savvy engineers is now daily output from tools like Windsurf, Claude Code and Lovable.</p>

    <h2>A Double-Edged Sword</h2>
    
    <p>Uncle Ben said it best: "With great power comes great responsibility." That's never been truer than when ambitious developers deploy AI-generated code to users who depend on these platforms for their social, financial and medical needs. AI is helpful, but it doesn't produce perfect code. In fact, LLMs make mistakes at a higher rate than thoughtful human developers. Writing code with AI today is a double-edged sword.</p>

    <p>That edge cuts deepest in testing. Vibe-coded apps may appear functional in the browser, but their underlying code is often bloated, disorganized and difficult to maintain. I frequently see DOM trees that contain thousands of deeply nested, nonstandard elements. No documentation, no spec, no clear intention—just opaque markup glued together with bulky scripts. (Cue Homer Simpson holding himself together with clothespins.)</p>

    <h2>Under The Browser's Surface</h2>
    
    <p>Many "AI-native" browser automation tools still cling to the outdated idea that the DOM is a reliable source of truth. That might have worked for hand-coded web apps from 2010, but today's AI-generated UIs, minified JavaScript runtimes, <code>&lt;canvas&gt;</code> rendering and frameworks like Flutter make it less reliable.</p>

    <p>As data flows from the server to the browser, into a context window and finally into an LLM, detail and fidelity are lost at every step: a process I call the loss chain. By the time the agent acts, it's working from abstractions that no longer match what's actually on the screen.</p>

    <p>DOM elements also don't behave like fully rendered UIs. Try finding the right <code>&lt;div&gt;</code> that's supposed to be a login button when its click handler is buried in minified code. That makes it hard for automation to know what to click, and when apps rely on graphics or canvas-based interfaces, testing tools can break down into guesswork.</p>

    <h2>Vision As The Source Of Truth</h2>
    
    <p>I've been researching browser agents, testing frameworks and vision models full time since the beginning of this year. This intense focus is no accident—it's the main building block of my startup. Having previously worked as a software engineer on projects aimed at catching regressions, I've seen firsthand the limitations of traditional approaches. I've also had the privilege of meeting fellow founders working in the browser automation space to discuss these exact challenges.</p>

    <p>Based on this, I believe the solution is computer vision: equipping automation tools with eyes and hands (screenshots and virtual peripheral devices). This avoids the loss chain entirely by letting the AI act on what is actually rendered in the browser, not on an abstraction.</p>

    <p>The AI agent is more effective when it can click the login button it sees, rather than guessing at one buried in a DOM tree that exists solely to appease the renderer. For modern vibe-coded apps, the rendered screen is the source of truth, not the markup.</p>

    <h2>Trade-Offs In Vision-Based Testing</h2>
    
    <p>It's true that vision-based testing is still slower, more expensive and less mature than DOM-based frameworks. But that's changing fast. Vision models are getting faster, inference costs are dropping and open-weight contenders like ByteDance's UI-TARS are already challenging Anthropic's CUA.</p>

    <p>So, when do these trade-offs matter most?</p>

    <p>For projects with read-heavy workflows (like text ingestion, scraping and research), DOM-based frameworks are often still the better choice. Vision models rely on optical character recognition (OCR) and an LLM's reasoning for text comprehension, which can cause them to struggle with small fonts and misidentify placeholders and long, nonsensical strings like URLs or hashes. Without context beyond a screenshot of the viewport, they can also misinterpret icons and buttons that lack accompanying text.</p>

    <p>On the flip side, vision models excel at write-heavy tasks that require a lot of interaction with a webpage. In my experience, they are great for handling things like canvases, iframes, scrollable containers, drag-and-drop actions and nonstandard input components. If you're testing applications like design tools or games, the visual approach might be worth the extra cost and time.</p>

    <h2>Building Tools That See</h2>
    
    <p>Computer use is inherently visual. We design interfaces for humans to look at and interact with using a mouse and keyboard. If AI aims to be the brain, it needs eyes and hands. In the age of vibe-code, don't lock yourself into a DOM-shaped view of the world. Build tools that see.</p>

    <hr>

    <p style="text-align: center; margin-top: 2rem;">
      <a href="index.html">← Back to home</a>
    </p>

    <p style="font-size: 12px; color: #999; text-align: center; margin-top: 2rem;">© <span id="year"></span> Boris Skurikhin</p>
    <script>
      document.getElementById('year').textContent = new Date().getFullYear();
    </script>
  </body>
</html>